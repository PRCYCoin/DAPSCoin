<<<<<<< HEAD
#!/usr/bin/env python
from __future__ import division, print_function, unicode_literals
=======
#!/usr/bin/env python3
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
#
# Copyright (C) 2011  Patrick "p2k" Schneider <me@p2k-network.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

<<<<<<< HEAD
import subprocess, sys, re, os, shutil, stat, os.path, time
from string import Template
from argparse import ArgumentParser
=======
import plistlib
import sys, re, os, shutil, stat, os.path
from argparse import ArgumentParser
from ds_store import DSStore
from mac_alias import Alias
from pathlib import Path
from subprocess import PIPE, run
from typing import List, Optional
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

# This is ported from the original macdeployqt with modifications

class FrameworkInfo(object):
    def __init__(self):
        self.frameworkDirectory = ""
        self.frameworkName = ""
        self.frameworkPath = ""
        self.binaryDirectory = ""
        self.binaryName = ""
        self.binaryPath = ""
        self.version = ""
        self.installName = ""
        self.deployedInstallName = ""
        self.sourceFilePath = ""
        self.destinationDirectory = ""
        self.sourceResourcesDirectory = ""
        self.sourceVersionContentsDirectory = ""
        self.sourceContentsDirectory = ""
        self.destinationResourcesDirectory = ""
        self.destinationVersionContentsDirectory = ""

    def __eq__(self, other):
        if self.__class__ == other.__class__:
            return self.__dict__ == other.__dict__
        else:
            return False

    def __str__(self):
<<<<<<< HEAD
        return """ Framework name: %s
 Framework directory: %s
 Framework path: %s
 Binary name: %s
 Binary directory: %s
 Binary path: %s
 Version: %s
 Install name: %s
 Deployed install name: %s
 Source file Path: %s
 Deployed Directory (relative to bundle): %s
""" % (self.frameworkName,
       self.frameworkDirectory,
       self.frameworkPath,
       self.binaryName,
       self.binaryDirectory,
       self.binaryPath,
       self.version,
       self.installName,
       self.deployedInstallName,
       self.sourceFilePath,
       self.destinationDirectory)
=======
        return f""" Framework name: {frameworkName}
 Framework directory: {self.frameworkDirectory}
 Framework path: {self.frameworkPath}
 Binary name: {self.binaryName}
 Binary directory: {self.binaryDirectory}
 Binary path: {self.binaryPath}
 Version: {self.version}
 Install name: {self.installName}
 Deployed install name: {self.deployedInstallName}
 Source file Path: {self.sourceFilePath}
 Deployed Directory (relative to bundle): {self.destinationDirectory}
"""
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

    def isDylib(self):
        return self.frameworkName.endswith(".dylib")

    def isQtFramework(self):
        if self.isDylib():
            return self.frameworkName.startswith("libQt")
        else:
            return self.frameworkName.startswith("Qt")

    reOLine = re.compile(r'^(.+) \(compatibility version [0-9.]+, current version [0-9.]+\)$')
    bundleFrameworkDirectory = "Contents/Frameworks"
    bundleBinaryDirectory = "Contents/MacOS"

    @classmethod
<<<<<<< HEAD
    def fromOtoolLibraryLine(cls, line):
=======
    def fromOtoolLibraryLine(cls, line: str) -> Optional['FrameworkInfo']:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        # Note: line must be trimmed
        if line == "":
            return None

        # Don't deploy system libraries (exception for libQtuitools and libQtlucene).
        if line.startswith("/System/Library/") or line.startswith("@executable_path") or (line.startswith("/usr/lib/") and "libQt" not in line):
            return None

        m = cls.reOLine.match(line)
        if m is None:
<<<<<<< HEAD
            raise RuntimeError("otool line could not be parsed: " + line)
=======
            raise RuntimeError(f"otool line could not be parsed: {line}")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

        path = m.group(1)

        info = cls()
        info.sourceFilePath = path
        info.installName = path

        if path.endswith(".dylib"):
            dirname, filename = os.path.split(path)
            info.frameworkName = filename
            info.frameworkDirectory = dirname
            info.frameworkPath = path

            info.binaryDirectory = dirname
            info.binaryName = filename
            info.binaryPath = path
            info.version = "-"

            info.installName = path
<<<<<<< HEAD
            info.deployedInstallName = "@executable_path/../Frameworks/" + info.binaryName
=======
            info.deployedInstallName = f"@executable_path/../Frameworks/{info.binaryName}"
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
            info.sourceFilePath = path
            info.destinationDirectory = cls.bundleFrameworkDirectory
        else:
            parts = path.split("/")
            i = 0
            # Search for the .framework directory
            for part in parts:
                if part.endswith(".framework"):
                    break
                i += 1
            if i == len(parts):
<<<<<<< HEAD
                raise RuntimeError("Could not find .framework or .dylib in otool line: " + line)
=======
                raise RuntimeError(f"Could not find .framework or .dylib in otool line: {line}")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

            info.frameworkName = parts[i]
            info.frameworkDirectory = "/".join(parts[:i])
            info.frameworkPath = os.path.join(info.frameworkDirectory, info.frameworkName)

            info.binaryName = parts[i+3]
            info.binaryDirectory = "/".join(parts[i+1:i+3])
            info.binaryPath = os.path.join(info.binaryDirectory, info.binaryName)
            info.version = parts[i+2]

<<<<<<< HEAD
            info.deployedInstallName = "@executable_path/../Frameworks/" + os.path.join(info.frameworkName, info.binaryPath)
=======
            info.deployedInstallName = f"@executable_path/../Frameworks/{os.path.join(info.frameworkName, info.binaryPath)}"
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
            info.destinationDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, info.binaryDirectory)

            info.sourceResourcesDirectory = os.path.join(info.frameworkPath, "Resources")
            info.sourceContentsDirectory = os.path.join(info.frameworkPath, "Contents")
            info.sourceVersionContentsDirectory = os.path.join(info.frameworkPath, "Versions", info.version, "Contents")
            info.destinationResourcesDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, "Resources")
<<<<<<< HEAD
            info.destinationContentsDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, "Contents")
=======
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
            info.destinationVersionContentsDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, "Versions", info.version, "Contents")

        return info

class ApplicationBundleInfo(object):
<<<<<<< HEAD
    def __init__(self, path):
        self.path = path
        appName = "PRCYcoin-Qt"
        self.binaryPath = os.path.join(path, "Contents", "MacOS", appName)
        if not os.path.exists(self.binaryPath):
            raise RuntimeError("Could not find bundle binary for " + path)
=======
    def __init__(self, path: str):
        self.path = path
        # for backwards compatibility reasons, this must remain as PIVX-Qt
        self.binaryPath = os.path.join(path, "Contents", "MacOS", "PIVX-Qt")
        if not os.path.exists(self.binaryPath):
            raise RuntimeError(f"Could not find bundle binary for {path}")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        self.resourcesPath = os.path.join(path, "Contents", "Resources")
        self.pluginPath = os.path.join(path, "Contents", "PlugIns")

class DeploymentInfo(object):
    def __init__(self):
        self.qtPath = None
        self.pluginPath = None
        self.deployedFrameworks = []

<<<<<<< HEAD
    def detectQtPath(self, frameworkDirectory):
=======
    def detectQtPath(self, frameworkDirectory: str):
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        parentDir = os.path.dirname(frameworkDirectory)
        if os.path.exists(os.path.join(parentDir, "translations")):
            # Classic layout, e.g. "/usr/local/Trolltech/Qt-4.x.x"
            self.qtPath = parentDir
<<<<<<< HEAD
        elif os.path.exists(os.path.join(parentDir, "share", "qt4", "translations")):
            # MacPorts layout, e.g. "/opt/local/share/qt4"
            self.qtPath = os.path.join(parentDir, "share", "qt4")
        elif os.path.exists(os.path.join(os.path.dirname(parentDir), "share", "qt4", "translations")):
            # Newer Macports layout
            self.qtPath = os.path.join(os.path.dirname(parentDir), "share", "qt4")
=======
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        else:
            self.qtPath = os.getenv("QTDIR", None)

        if self.qtPath is not None:
            pluginPath = os.path.join(self.qtPath, "plugins")
            if os.path.exists(pluginPath):
                self.pluginPath = pluginPath

<<<<<<< HEAD
    def usesFramework(self, name):
        nameDot = "%s." % name
        libNameDot = "lib%s." % name
        for framework in self.deployedFrameworks:
            if framework.endswith(".framework"):
                if framework.startswith(nameDot):
                    return True
            elif framework.endswith(".dylib"):
                if framework.startswith(libNameDot):
                    return True
        return False

def getFrameworks(binaryPath, verbose):
    if verbose >= 3:
        print("Inspecting with otool: " + binaryPath)
    otoolbin=os.getenv("OTOOL", "otool")
    otool = subprocess.Popen([otoolbin, "-L", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    o_stdout, o_stderr = otool.communicate()
    if otool.returncode != 0:
        if verbose >= 1:
            sys.stderr.write(o_stderr)
            sys.stderr.flush()
            raise RuntimeError("otool failed with return code %d" % otool.returncode)

    otoolLines = o_stdout.decode().split("\n")
=======
    def usesFramework(self, name: str) -> bool:
        for framework in self.deployedFrameworks:
            if framework.endswith(".framework"):
                if framework.startswith(f"{name}."):
                    return True
            elif framework.endswith(".dylib"):
                if framework.startswith(f"lib{name}."):
                    return True
        return False

def getFrameworks(binaryPath: str, verbose: int) -> List[FrameworkInfo]:
    if verbose:
        print(f"Inspecting with otool: {binaryPath}")
    otoolbin=os.getenv("OTOOL", "otool")
    otool = run([otoolbin, "-L", binaryPath], stdout=PIPE, stderr=PIPE, universal_newlines=True)
    if otool.returncode != 0:
        sys.stderr.write(otool.stderr)
        sys.stderr.flush()
        raise RuntimeError(f"otool failed with return code {otool.returncode}")

    otoolLines = otool.stdout.split("\n")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
    otoolLines.pop(0) # First line is the inspected binary
    if ".framework" in binaryPath or binaryPath.endswith(".dylib"):
        otoolLines.pop(0) # Frameworks and dylibs list themselves as a dependency.

    libraries = []
    for line in otoolLines:
        line = line.replace("@loader_path", os.path.dirname(binaryPath))
        info = FrameworkInfo.fromOtoolLibraryLine(line.strip())
        if info is not None:
<<<<<<< HEAD
            if verbose >= 3:
=======
            if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
                print("Found framework:")
                print(info)
            libraries.append(info)

    return libraries

<<<<<<< HEAD
def runInstallNameTool(action, *args):
    installnametoolbin=os.getenv("INSTALLNAMETOOL", "install_name_tool")
    subprocess.check_call([installnametoolbin, "-"+action] + list(args))

def changeInstallName(oldName, newName, binaryPath, verbose):
    if verbose >= 3:
=======
def runInstallNameTool(action: str, *args):
    installnametoolbin=os.getenv("INSTALLNAMETOOL", "install_name_tool")
    run([installnametoolbin, "-"+action] + list(args), check=True)

def changeInstallName(oldName: str, newName: str, binaryPath: str, verbose: int):
    if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        print("Using install_name_tool:")
        print(" in", binaryPath)
        print(" change reference", oldName)
        print(" to", newName)
    runInstallNameTool("change", oldName, newName, binaryPath)

<<<<<<< HEAD
def changeIdentification(id, binaryPath, verbose):
    if verbose >= 3:
=======
def changeIdentification(id: str, binaryPath: str, verbose: int):
    if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        print("Using install_name_tool:")
        print(" change identification in", binaryPath)
        print(" to", id)
    runInstallNameTool("id", id, binaryPath)

<<<<<<< HEAD
def runStrip(binaryPath, verbose):
    stripbin=os.getenv("STRIP", "strip")
    if verbose >= 3:
        print("Using strip:")
        print(" stripped", binaryPath)
    subprocess.check_call([stripbin, "-x", binaryPath])

def copyFramework(framework, path, verbose):
    if framework.sourceFilePath.startswith("Qt"):
        #standard place for Nokia Qt installer's frameworks
        fromPath = "/Library/Frameworks/" + framework.sourceFilePath
=======
def runStrip(binaryPath: str, verbose: int):
    stripbin=os.getenv("STRIP", "strip")
    if verbose:
        print("Using strip:")
        print(" stripped", binaryPath)
    run([stripbin, "-x", binaryPath], check=True)

def copyFramework(framework: FrameworkInfo, path: str, verbose: int) -> Optional[str]:
    if framework.sourceFilePath.startswith("Qt"):
        #standard place for Nokia Qt installer's frameworks
        fromPath = f"/Library/Frameworks/{framework.sourceFilePath}"
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
    else:
        fromPath = framework.sourceFilePath
    toDir = os.path.join(path, framework.destinationDirectory)
    toPath = os.path.join(toDir, framework.binaryName)

    if not os.path.exists(fromPath):
<<<<<<< HEAD
        raise RuntimeError("No file at " + fromPath)
=======
        raise RuntimeError(f"No file at {fromPath}")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

    if os.path.exists(toPath):
        return None # Already there

    if not os.path.exists(toDir):
        os.makedirs(toDir)

    shutil.copy2(fromPath, toPath)
<<<<<<< HEAD
    if verbose >= 3:
=======
    if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        print("Copied:", fromPath)
        print(" to:", toPath)

    permissions = os.stat(toPath)
    if not permissions.st_mode & stat.S_IWRITE:
      os.chmod(toPath, permissions.st_mode | stat.S_IWRITE)

    if not framework.isDylib(): # Copy resources for real frameworks

        linkfrom = os.path.join(path, "Contents","Frameworks", framework.frameworkName, "Versions", "Current")
        linkto = framework.version
        if not os.path.exists(linkfrom):
            os.symlink(linkto, linkfrom)
<<<<<<< HEAD
            if verbose >= 2:
                print("Linked:", linkfrom, "->", linkto)
=======
            print("Linked:", linkfrom, "->", linkto)
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        fromResourcesDir = framework.sourceResourcesDirectory
        if os.path.exists(fromResourcesDir):
            toResourcesDir = os.path.join(path, framework.destinationResourcesDirectory)
            shutil.copytree(fromResourcesDir, toResourcesDir, symlinks=True)
<<<<<<< HEAD
            if verbose >= 3:
=======
            if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
                print("Copied resources:", fromResourcesDir)
                print(" to:", toResourcesDir)
        fromContentsDir = framework.sourceVersionContentsDirectory
        if not os.path.exists(fromContentsDir):
            fromContentsDir = framework.sourceContentsDirectory
        if os.path.exists(fromContentsDir):
            toContentsDir = os.path.join(path, framework.destinationVersionContentsDirectory)
            shutil.copytree(fromContentsDir, toContentsDir, symlinks=True)
<<<<<<< HEAD
            if verbose >= 3:
=======
            if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
                print("Copied Contents:", fromContentsDir)
                print(" to:", toContentsDir)
    elif framework.frameworkName.startswith("libQtGui"): # Copy qt_menu.nib (applies to non-framework layout)
        qtMenuNibSourcePath = os.path.join(framework.frameworkDirectory, "Resources", "qt_menu.nib")
        qtMenuNibDestinationPath = os.path.join(path, "Contents", "Resources", "qt_menu.nib")
        if os.path.exists(qtMenuNibSourcePath) and not os.path.exists(qtMenuNibDestinationPath):
            shutil.copytree(qtMenuNibSourcePath, qtMenuNibDestinationPath, symlinks=True)
<<<<<<< HEAD
            if verbose >= 3:
=======
            if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
                print("Copied for libQtGui:", qtMenuNibSourcePath)
                print(" to:", qtMenuNibDestinationPath)

    return toPath

<<<<<<< HEAD
def deployFrameworks(frameworks, bundlePath, binaryPath, strip, verbose, deploymentInfo=None):
=======
def deployFrameworks(frameworks: List[FrameworkInfo], bundlePath: str, binaryPath: str, strip: bool, verbose: int, deploymentInfo: Optional[DeploymentInfo] = None) -> DeploymentInfo:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
    if deploymentInfo is None:
        deploymentInfo = DeploymentInfo()

    while len(frameworks) > 0:
        framework = frameworks.pop(0)
        deploymentInfo.deployedFrameworks.append(framework.frameworkName)

<<<<<<< HEAD
        if verbose >= 2:
            print("Processing", framework.frameworkName, "...")
=======
        print("Processing", framework.frameworkName, "...")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

        # Get the Qt path from one of the Qt frameworks
        if deploymentInfo.qtPath is None and framework.isQtFramework():
            deploymentInfo.detectQtPath(framework.frameworkDirectory)

        if framework.installName.startswith("@executable_path") or framework.installName.startswith(bundlePath):
<<<<<<< HEAD
            if verbose >= 2:
                print(framework.frameworkName, "already deployed, skipping.")
=======
            print(framework.frameworkName, "already deployed, skipping.")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
            continue

        # install_name_tool the new id into the binary
        changeInstallName(framework.installName, framework.deployedInstallName, binaryPath, verbose)

        # Copy framework to app bundle.
        deployedBinaryPath = copyFramework(framework, bundlePath, verbose)
        # Skip the rest if already was deployed.
        if deployedBinaryPath is None:
            continue

        if strip:
            runStrip(deployedBinaryPath, verbose)

        # install_name_tool it a new id.
        changeIdentification(framework.deployedInstallName, deployedBinaryPath, verbose)
        # Check for framework dependencies
        dependencies = getFrameworks(deployedBinaryPath, verbose)

        for dependency in dependencies:
            changeInstallName(dependency.installName, dependency.deployedInstallName, deployedBinaryPath, verbose)

            # Deploy framework if necessary.
            if dependency.frameworkName not in deploymentInfo.deployedFrameworks and dependency not in frameworks:
                frameworks.append(dependency)

    return deploymentInfo

<<<<<<< HEAD
def deployFrameworksForAppBundle(applicationBundle, strip, verbose):
    frameworks = getFrameworks(applicationBundle.binaryPath, verbose)
    if len(frameworks) == 0 and verbose >= 1:
        print("Warning: Could not find any external frameworks to deploy in %s." % (applicationBundle.path))
=======
def deployFrameworksForAppBundle(applicationBundle: ApplicationBundleInfo, strip: bool, verbose: int) -> DeploymentInfo:
    frameworks = getFrameworks(applicationBundle.binaryPath, verbose)
    if len(frameworks) == 0:
        print(f"Warning: Could not find any external frameworks to deploy in {applicationBundle.path}.")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        return DeploymentInfo()
    else:
        return deployFrameworks(frameworks, applicationBundle.path, applicationBundle.binaryPath, strip, verbose)

<<<<<<< HEAD
def deployPlugins(appBundleInfo, deploymentInfo, strip, verbose):
=======
def deployPlugins(appBundleInfo: ApplicationBundleInfo, deploymentInfo: DeploymentInfo, strip: bool, verbose: int):
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
    # Lookup available plugins, exclude unneeded
    plugins = []
    if deploymentInfo.pluginPath is None:
        return
    for dirpath, dirnames, filenames in os.walk(deploymentInfo.pluginPath):
        pluginDirectory = os.path.relpath(dirpath, deploymentInfo.pluginPath)
        if pluginDirectory == "designer":
            # Skip designer plugins
            continue
<<<<<<< HEAD
        elif pluginDirectory == "phonon" or pluginDirectory == "phonon_backend":
            # Deploy the phonon plugins only if phonon is in use
            if not deploymentInfo.usesFramework("phonon"):
                continue
=======
        elif pluginDirectory == "printsupport":
            # Skip printsupport plugins
            continue
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        elif pluginDirectory == "sqldrivers":
            # Deploy the sql plugins only if QtSql is in use
            if not deploymentInfo.usesFramework("QtSql"):
                continue
        elif pluginDirectory == "script":
            # Deploy the script plugins only if QtScript is in use
            if not deploymentInfo.usesFramework("QtScript"):
                continue
        elif pluginDirectory == "qmltooling" or pluginDirectory == "qml1tooling":
            # Deploy the qml plugins only if QtDeclarative is in use
            if not deploymentInfo.usesFramework("QtDeclarative"):
                continue
        elif pluginDirectory == "bearer":
            # Deploy the bearer plugins only if QtNetwork is in use
            if not deploymentInfo.usesFramework("QtNetwork"):
                continue
        elif pluginDirectory == "position":
            # Deploy the position plugins only if QtPositioning is in use
            if not deploymentInfo.usesFramework("QtPositioning"):
                continue
        elif pluginDirectory == "sensors" or pluginDirectory == "sensorgestures":
            # Deploy the sensor plugins only if QtSensors is in use
            if not deploymentInfo.usesFramework("QtSensors"):
                continue
        elif pluginDirectory == "audio" or pluginDirectory == "playlistformats":
            # Deploy the audio plugins only if QtMultimedia is in use
            if not deploymentInfo.usesFramework("QtMultimedia"):
                continue
        elif pluginDirectory == "mediaservice":
            # Deploy the mediaservice plugins only if QtMultimediaWidgets is in use
            if not deploymentInfo.usesFramework("QtMultimediaWidgets"):
                continue
<<<<<<< HEAD
=======
        elif pluginDirectory == "canbus":
            # Deploy the canbus plugins only if QtSerialBus is in use
            if not deploymentInfo.usesFramework("QtSerialBus"):
                continue
        elif pluginDirectory == "webview":
            # Deploy the webview plugins only if QtWebView is in use
            if not deploymentInfo.usesFramework("QtWebView"):
                continue
        elif pluginDirectory == "gamepads":
            # Deploy the webview plugins only if QtGamepad is in use
            if not deploymentInfo.usesFramework("QtGamepad"):
                continue
        elif pluginDirectory == "geoservices":
            # Deploy the webview plugins only if QtLocation is in use
            if not deploymentInfo.usesFramework("QtLocation"):
                continue
        elif pluginDirectory == "texttospeech":
            # Deploy the texttospeech plugins only if QtTextToSpeech is in use
            if not deploymentInfo.usesFramework("QtTextToSpeech"):
                continue
        elif pluginDirectory == "virtualkeyboard":
            # Deploy the virtualkeyboard plugins only if QtVirtualKeyboard is in use
            if not deploymentInfo.usesFramework("QtVirtualKeyboard"):
                continue
        elif pluginDirectory == "sceneparsers":
            # Deploy the virtualkeyboard plugins only if Qt3DCore is in use
            if not deploymentInfo.usesFramework("Qt3DCore"):
                continue
        elif pluginDirectory == "renderplugins":
            # Deploy the renderplugins plugins only if Qt3DCore is in use
            if not deploymentInfo.usesFramework("Qt3DCore"):
                continue
        elif pluginDirectory == "geometryloaders":
            # Deploy the geometryloaders plugins only if Qt3DCore is in use
            if not deploymentInfo.usesFramework("Qt3DCore"):
                continue
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

        for pluginName in filenames:
            pluginPath = os.path.join(pluginDirectory, pluginName)
            if pluginName.endswith("_debug.dylib"):
                # Skip debug plugins
                continue
            elif pluginPath == "imageformats/libqsvg.dylib" or pluginPath == "iconengines/libqsvgicon.dylib":
                # Deploy the svg plugins only if QtSvg is in use
                if not deploymentInfo.usesFramework("QtSvg"):
<<<<<<< HEAD
                    continue
=======
                    print ("qtSVG NOT FOUND")
                    continue
                else:
                    print ("qtSVG FOUND!")
                #a = deploymentInfo.usesFramework("QtSvg")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
            elif pluginPath == "accessible/libqtaccessiblecompatwidgets.dylib":
                # Deploy accessibility for Qt3Support only if the Qt3Support is in use
                if not deploymentInfo.usesFramework("Qt3Support"):
                    continue
            elif pluginPath == "graphicssystems/libqglgraphicssystem.dylib":
                # Deploy the opengl graphicssystem plugin only if QtOpenGL is in use
                if not deploymentInfo.usesFramework("QtOpenGL"):
                    continue
            elif pluginPath == "accessible/libqtaccessiblequick.dylib":
                # Deploy the accessible qtquick plugin only if QtQuick is in use
                if not deploymentInfo.usesFramework("QtQuick"):
                    continue
<<<<<<< HEAD
=======
            elif pluginPath == "platforminputcontexts/libqtvirtualkeyboardplugin.dylib":
                # Deploy the virtualkeyboardplugin plugin only if QtVirtualKeyboard is in use
                if not deploymentInfo.usesFramework("QtVirtualKeyboard"):
                    continue
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

            plugins.append((pluginDirectory, pluginName))

    for pluginDirectory, pluginName in plugins:
<<<<<<< HEAD
        if verbose >= 2:
            print("Processing plugin", os.path.join(pluginDirectory, pluginName), "...")
=======
        print("Processing plugin", os.path.join(pluginDirectory, pluginName), "...")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

        sourcePath = os.path.join(deploymentInfo.pluginPath, pluginDirectory, pluginName)
        destinationDirectory = os.path.join(appBundleInfo.pluginPath, pluginDirectory)
        if not os.path.exists(destinationDirectory):
            os.makedirs(destinationDirectory)

        destinationPath = os.path.join(destinationDirectory, pluginName)
        shutil.copy2(sourcePath, destinationPath)
<<<<<<< HEAD
        if verbose >= 3:
=======
        if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
            print("Copied:", sourcePath)
            print(" to:", destinationPath)

        if strip:
            runStrip(destinationPath, verbose)

        dependencies = getFrameworks(destinationPath, verbose)

        for dependency in dependencies:
            changeInstallName(dependency.installName, dependency.deployedInstallName, destinationPath, verbose)

            # Deploy framework if necessary.
            if dependency.frameworkName not in deploymentInfo.deployedFrameworks:
                deployFrameworks([dependency], appBundleInfo.path, destinationPath, strip, verbose, deploymentInfo)

<<<<<<< HEAD
qt_conf="""[Paths]
Translations=Resources
Plugins=PlugIns
"""

=======
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
ap = ArgumentParser(description="""Improved version of macdeployqt.

Outputs a ready-to-deploy app in a folder "dist" and optionally wraps it in a .dmg file.
Note, that the "dist" folder will be deleted before deploying on each run.

<<<<<<< HEAD
Optionally, Qt translation files (.qm) and additional resources can be added to the bundle.

Also optionally signs the .app bundle; set the CODESIGNARGS environment variable to pass arguments
to the codesign tool.
E.g. CODESIGNARGS='--sign "Developer ID Application: ..." --keychain /encrypted/foo.keychain'""")

ap.add_argument("app_bundle", nargs=1, metavar="app-bundle", help="application bundle to be deployed")
ap.add_argument("-verbose", type=int, nargs=1, default=[1], metavar="<0-3>", help="0 = no output, 1 = error/warning (default), 2 = normal, 3 = debug")
ap.add_argument("-no-plugins", dest="plugins", action="store_false", default=True, help="skip plugin deployment")
ap.add_argument("-no-strip", dest="strip", action="store_false", default=True, help="don't run 'strip' on the binaries")
ap.add_argument("-sign", dest="sign", action="store_true", default=False, help="sign .app bundle with codesign tool")
ap.add_argument("-dmg", nargs="?", const="", metavar="basename", help="create a .dmg disk image; if basename is not specified, a camel-cased version of the app name is used")
ap.add_argument("-fancy", nargs=1, metavar="plist", default=[], help="make a fancy looking disk image using the given plist file with instructions; requires -dmg to work")
ap.add_argument("-add-qt-tr", nargs=1, metavar="languages", default=[], help="add Qt translation files to the bundle's resources; the language list must be separated with commas, not with whitespace")
ap.add_argument("-translations-dir", nargs=1, metavar="path", default=None, help="Path to Qt's translation files")
ap.add_argument("-add-resources", nargs="+", metavar="path", default=[], help="list of additional files or folders to be copied into the bundle's resources; must be the last argument")
ap.add_argument("-volname", nargs=1, metavar="volname", default=[], help="custom volume name for dmg")

config = ap.parse_args()

verbose = config.verbose[0]
=======
Optionally, Qt translation files (.qm) can be added to the bundle.""")

ap.add_argument("app_bundle", nargs=1, metavar="app-bundle", help="application bundle to be deployed")
ap.add_argument("appname", nargs=1, metavar="appname", help="name of the app being deployed")
ap.add_argument("-verbose", nargs="?", const=True, help="Output additional debugging information")
ap.add_argument("-no-plugins", dest="plugins", action="store_false", default=True, help="skip plugin deployment")
ap.add_argument("-no-strip", dest="strip", action="store_false", default=True, help="don't run 'strip' on the binaries")
ap.add_argument("-dmg", nargs="?", const="", metavar="basename", help="create a .dmg disk image")
ap.add_argument("-translations-dir", nargs=1, metavar="path", default=None, help="Path to Qt's translations. Base translations will automatically be added to the bundle's resources.")

config = ap.parse_args()

verbose = config.verbose
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

# ------------------------------------------------

app_bundle = config.app_bundle[0]
<<<<<<< HEAD

if not os.path.exists(app_bundle):
    if verbose >= 1:
        sys.stderr.write("Error: Could not find app bundle \"%s\"\n" % (app_bundle))
    sys.exit(1)

app_bundle_name = os.path.splitext(os.path.basename(app_bundle))[0]

# ------------------------------------------------
translations_dir = None
if config.translations_dir and config.translations_dir[0]:
    if os.path.exists(config.translations_dir[0]):
        translations_dir = config.translations_dir[0]
    else:
        if verbose >= 1:
            sys.stderr.write("Error: Could not find translation dir \"%s\"\n" % (translations_dir))
        sys.exit(1)
# ------------------------------------------------

for p in config.add_resources:
    if verbose >= 3:
        print("Checking for \"%s\"..." % p)
    if not os.path.exists(p):
        if verbose >= 1:
            sys.stderr.write("Error: Could not find additional resource file \"%s\"\n" % (p))
        sys.exit(1)

# ------------------------------------------------

if len(config.fancy) == 1:
    if verbose >= 3:
        print("Fancy: Importing plistlib...")
    try:
        import plistlib
    except ImportError:
        if verbose >= 1:
            sys.stderr.write("Error: Could not import plistlib which is required for fancy disk images.\n")
        sys.exit(1)

    p = config.fancy[0]
    if verbose >= 3:
        print("Fancy: Loading \"%s\"..." % p)
    if not os.path.exists(p):
        if verbose >= 1:
            sys.stderr.write("Error: Could not find fancy disk image plist at \"%s\"\n" % (p))
        sys.exit(1)

    try:
        fancy = plistlib.readPlist(p)
    except:
        if verbose >= 1:
            sys.stderr.write("Error: Could not parse fancy disk image plist at \"%s\"\n" % (p))
        sys.exit(1)

    try:
        assert "window_bounds" not in fancy or (isinstance(fancy["window_bounds"], list) and len(fancy["window_bounds"]) == 4)
        assert "background_picture" not in fancy or isinstance(fancy["background_picture"], str)
        assert "icon_size" not in fancy or isinstance(fancy["icon_size"], int)
        assert "applications_symlink" not in fancy or isinstance(fancy["applications_symlink"], bool)
        if "items_position" in fancy:
            assert isinstance(fancy["items_position"], dict)
            for key, value in fancy["items_position"].items():
                assert isinstance(value, list) and len(value) == 2 and isinstance(value[0], int) and isinstance(value[1], int)
    except:
        if verbose >= 1:
            sys.stderr.write("Error: Bad format of fancy disk image plist at \"%s\"\n" % (p))
        sys.exit(1)

    if "background_picture" in fancy:
        bp = fancy["background_picture"]
        if verbose >= 3:
            print("Fancy: Resolving background picture \"%s\"..." % bp)
        if not os.path.exists(bp):
            bp = os.path.join(os.path.dirname(p), bp)
            if not os.path.exists(bp):
                if verbose >= 1:
                    sys.stderr.write("Error: Could not find background picture at \"%s\" or \"%s\"\n" % (fancy["background_picture"], bp))
                sys.exit(1)
            else:
                fancy["background_picture"] = bp
else:
    fancy = None

# ------------------------------------------------

if os.path.exists("dist"):
    if verbose >= 2:
        print("+ Removing old dist folder +")

    shutil.rmtree("dist")

# ------------------------------------------------

if len(config.volname) == 1:
    volname = config.volname[0]
else:
    volname = app_bundle_name

# ------------------------------------------------

target = os.path.join("dist", "PRCYcoin-Qt.app")

if verbose >= 2:
    print("+ Copying source bundle +")
if verbose >= 3:
=======
appname = config.appname[0]

if not os.path.exists(app_bundle):
    sys.stderr.write(f"Error: Could not find app bundle \"{app_bundle}\"\n")
    sys.exit(1)

# ------------------------------------------------

if os.path.exists("dist"):
    print("+ Removing existing dist folder +")
    shutil.rmtree("dist")

if os.path.exists(appname + ".dmg"):
    print("+ Removing existing DMG +")
    os.unlink(appname + ".dmg")

# ------------------------------------------------

target = os.path.join("dist", "PIVX-Qt.app")

print("+ Copying source bundle +")
if verbose:
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
    print(app_bundle, "->", target)

os.mkdir("dist")
shutil.copytree(app_bundle, target, symlinks=True)

applicationBundle = ApplicationBundleInfo(target)

# ------------------------------------------------

<<<<<<< HEAD
if verbose >= 2:
    print("+ Deploying frameworks +")
=======
print("+ Deploying frameworks +")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

try:
    deploymentInfo = deployFrameworksForAppBundle(applicationBundle, config.strip, verbose)
    if deploymentInfo.qtPath is None:
        deploymentInfo.qtPath = os.getenv("QTDIR", None)
        if deploymentInfo.qtPath is None:
<<<<<<< HEAD
            if verbose >= 1:
                sys.stderr.write("Warning: Could not detect Qt's path, skipping plugin deployment!\n")
            config.plugins = False
except RuntimeError as e:
    if verbose >= 1:
        sys.stderr.write("Error: %s\n" % str(e))
=======
            sys.stderr.write("Warning: Could not detect Qt's path, skipping plugin deployment!\n")
            config.plugins = False
except RuntimeError as e:
    sys.stderr.write(f"Error: {str(e)}\n")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
    sys.exit(1)

# ------------------------------------------------

if config.plugins:
<<<<<<< HEAD
    if verbose >= 2:
        print("+ Deploying plugins +")
=======
    print("+ Deploying plugins +")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

    try:
        deployPlugins(applicationBundle, deploymentInfo, config.strip, verbose)
    except RuntimeError as e:
<<<<<<< HEAD
        if verbose >= 1:
            sys.stderr.write("Error: %s\n" % str(e))
=======
        sys.stderr.write(f"Error: {str(e)}\n")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e
        sys.exit(1)

# ------------------------------------------------

<<<<<<< HEAD
if len(config.add_qt_tr) == 0:
    add_qt_tr = []
else:
    if translations_dir is not None:
        qt_tr_dir = translations_dir
    else:
        if deploymentInfo.qtPath is not None:
            qt_tr_dir = os.path.join(deploymentInfo.qtPath, "translations")
        else:
            sys.stderr.write("Error: Could not find Qt translation path\n")
            sys.exit(1)
    add_qt_tr = ["qt_%s.qm" % lng for lng in config.add_qt_tr[0].split(",")]
    for lng_file in add_qt_tr:
        p = os.path.join(qt_tr_dir, lng_file)
        if verbose >= 3:
            print("Checking for \"%s\"..." % p)
        if not os.path.exists(p):
            if verbose >= 1:
                sys.stderr.write("Error: Could not find Qt translation file \"%s\"\n" % (lng_file))
                sys.exit(1)

# ------------------------------------------------

if verbose >= 2:
    print("+ Installing qt.conf +")
=======
if config.translations_dir:
    if not Path(config.translations_dir[0]).exists():
        sys.stderr.write(f"Error: Could not find translation dir \"{config.translations_dir[0]}\"\n")
        sys.exit(1)

print("+ Adding Qt translations +")

translations = Path(config.translations_dir[0])

regex = re.compile('qt_[a-z]*(.qm|_[A-Z]*.qm)')

lang_files = [x for x in translations.iterdir() if regex.match(x.name)]

for file in lang_files:
    if verbose:
        print(file.as_posix(), "->", os.path.join(applicationBundle.resourcesPath, file.name))
    shutil.copy2(file.as_posix(), os.path.join(applicationBundle.resourcesPath, file.name))

# ------------------------------------------------

print("+ Installing qt.conf +")

qt_conf="""[Paths]
Translations=Resources
Plugins=PlugIns
"""
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

with open(os.path.join(applicationBundle.resourcesPath, "qt.conf"), "wb") as f:
    f.write(qt_conf.encode())

# ------------------------------------------------

<<<<<<< HEAD
if len(add_qt_tr) > 0 and verbose >= 2:
    print("+ Adding Qt translations +")

for lng_file in add_qt_tr:
    if verbose >= 3:
        print(os.path.join(qt_tr_dir, lng_file), "->", os.path.join(applicationBundle.resourcesPath, lng_file))
    shutil.copy2(os.path.join(qt_tr_dir, lng_file), os.path.join(applicationBundle.resourcesPath, lng_file))

# ------------------------------------------------

if len(config.add_resources) > 0 and verbose >= 2:
    print("+ Adding additional resources +")

for p in config.add_resources:
    t = os.path.join(applicationBundle.resourcesPath, os.path.basename(p))
    if verbose >= 3:
        print(p, "->", t)
    if os.path.isdir(p):
        shutil.copytree(p, t, symlinks=True)
    else:
        shutil.copy2(p, t)

# ------------------------------------------------

if config.sign and 'CODESIGNARGS' not in os.environ:
    print("You must set the CODESIGNARGS environment variable. Skipping signing.")
elif config.sign:
    if verbose >= 1:
        print("Code-signing app bundle %s"%(target,))
    subprocess.check_call("codesign --force %s %s"%(os.environ['CODESIGNARGS'], target), shell=True)

# ------------------------------------------------

if config.dmg is not None:

    #Patch in check_output for Python 2.6
    if "check_output" not in dir( subprocess ):
        def f(*popenargs, **kwargs):
            if 'stdout' in kwargs:
                raise ValueError('stdout argument not allowed, it will be overridden.')
            process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
            output, unused_err = process.communicate()
            retcode = process.poll()
            if retcode:
                cmd = kwargs.get("args")
                if cmd is None:
                    cmd = popenargs[0]
                raise CalledProcessError(retcode, cmd)
            return output
        subprocess.check_output = f

    def runHDIUtil(verb, image_basename, **kwargs):
        hdiutil_args = ["hdiutil", verb, image_basename + ".dmg"]
        if "capture_stdout" in kwargs:
            del kwargs["capture_stdout"]
            run = subprocess.check_output
        else:
            if verbose < 2:
                hdiutil_args.append("-quiet")
            elif verbose >= 3:
                hdiutil_args.append("-verbose")
            run = subprocess.check_call

        for key, value in kwargs.items():
            hdiutil_args.append("-" + key)
            if not value is True:
                hdiutil_args.append(str(value))

        return run(hdiutil_args)

    if verbose >= 2:
        if fancy is None:
            print("+ Creating .dmg disk image +")
        else:
            print("+ Preparing .dmg disk image +")

    if config.dmg != "":
        dmg_name = config.dmg
    else:
        spl = app_bundle_name.split(" ")
        dmg_name = spl[0] + "".join(p.capitalize() for p in spl[1:])

    if fancy is None:
        try:
            runHDIUtil("create", dmg_name, srcfolder="dist", format="UDBZ", volname=volname, ov=True)
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)
    else:
        if verbose >= 3:
            print("Determining size of \"dist\"...")
        size = 0
        for path, dirs, files in os.walk("dist"):
            for file in files:
                size += os.path.getsize(os.path.join(path, file))
        size += int(size * 0.15)

        if verbose >= 3:
            print("Creating temp image for modification...")
        try:
            runHDIUtil("create", dmg_name + ".temp", srcfolder="dist", format="UDRW", size=size, volname=volname, ov=True)
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)

        if verbose >= 3:
            print("Attaching temp image...")
        try:
            output = runHDIUtil("attach", dmg_name + ".temp", readwrite=True, noverify=True, noautoopen=True, capture_stdout=True)
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)

        m = re.search("/Volumes/(.+$)", output.decode())
        disk_root = m.group(0)
        disk_name = m.group(1)

        if verbose >= 2:
            print("+ Applying fancy settings +")

        if "background_picture" in fancy:
            bg_path = os.path.join(disk_root, ".background", os.path.basename(fancy["background_picture"]))
            os.mkdir(os.path.dirname(bg_path))
            if verbose >= 3:
                print(fancy["background_picture"], "->", bg_path)
            shutil.copy2(fancy["background_picture"], bg_path)
        else:
            bg_path = None

        if fancy.get("applications_symlink", False):
            os.symlink("/Applications", os.path.join(disk_root, "Applications"))

        # The Python appscript package broke with OSX 10.8 and isn't being fixed.
        # So we now build up an AppleScript string and use the osascript command
        # to make the .dmg file pretty:
        appscript = Template( """
        on run argv
           tell application "Finder"
             tell disk "$disk"
                   open
                   set current view of container window to icon view
                   set toolbar visible of container window to false
                   set statusbar visible of container window to false
                   set the bounds of container window to {$window_bounds}
                   set theViewOptions to the icon view options of container window
                   set arrangement of theViewOptions to not arranged
                   set icon size of theViewOptions to $icon_size
                   $background_commands
                   $items_positions
                   close -- close/reopen works around a bug...
                   open
                   update without registering applications
                   delay 5
                   eject
             end tell
           end tell
        end run
        """)

        itemscript = Template('set position of item "${item}" of container window to {${position}}')
        items_positions = []
        if "items_position" in fancy:
            for name, position in fancy["items_position"].items():
                params = { "item" : name, "position" : ",".join([str(p) for p in position]) }
                items_positions.append(itemscript.substitute(params))

        params = {
            "disk" : volname,
            "window_bounds" : "300,300,800,620",
            "icon_size" : "96",
            "background_commands" : "",
            "items_positions" : "\n                   ".join(items_positions)
            }
        if "window_bounds" in fancy:
            params["window_bounds"] = ",".join([str(p) for p in fancy["window_bounds"]])
        if "icon_size" in fancy:
            params["icon_size"] = str(fancy["icon_size"])
        if bg_path is not None:
            # Set background file, then call SetFile to make it invisible.
            # (note: making it invisible first makes set background picture fail)
            bgscript = Template("""set background picture of theViewOptions to file ".background:$bgpic"
                   do shell script "SetFile -a V /Volumes/$disk/.background/$bgpic" """)
            params["background_commands"] = bgscript.substitute({"bgpic" : os.path.basename(bg_path), "disk" : params["disk"]})

        s = appscript.substitute(params)
        if verbose >= 2:
            print("Running AppleScript:")
            print(s)

        p = subprocess.Popen(['osascript', '-'], stdin=subprocess.PIPE)
        p.communicate(input=s.encode('utf-8'))
        if p.returncode:
            print("Error running osascript.")

        if verbose >= 2:
            print("+ Finalizing .dmg disk image +")
            time.sleep(5)

        try:
            runHDIUtil("convert", dmg_name + ".temp", format="UDBZ", o=dmg_name + ".dmg", ov=True)
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)

        os.unlink(dmg_name + ".temp.dmg")

# ------------------------------------------------

if verbose >= 2:
    print("+ Done +")
=======
print("+ Generating .DS_Store +")

output_file = os.path.join("dist", ".DS_Store")

ds = DSStore.open(output_file, 'w+')

ds['.']['bwsp'] = {
    'WindowBounds': '{{300, 280}, {500, 343}}',
    'PreviewPaneVisibility': False,
}

icvp = {
    'gridOffsetX': 0.0,
    'textSize': 12.0,
    'viewOptionsVersion': 1,
    'backgroundImageAlias': b'\x00\x00\x00\x00\x02\x1a\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd1\x94\\\xb0H+\x00\x05\x00\x00\x00\x98\x0fbackground.tiff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x99\xd19\xb0\xf8\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\r\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b.background\x00\x00\x10\x00\x08\x00\x00\xd1\x94\\\xb0\x00\x00\x00\x11\x00\x08\x00\x00\xd19\xb0\xf8\x00\x00\x00\x01\x00\x04\x00\x00\x00\x98\x00\x0e\x00 \x00\x0f\x00b\x00a\x00c\x00k\x00g\x00r\x00o\x00u\x00n\x00d\x00.\x00t\x00i\x00f\x00f\x00\x0f\x00\x02\x00\x00\x00\x12\x00\x1c/.background/background.tiff\x00\x14\x01\x02\x00\x00\x00\x00\x01\x02\x00\x02\x00\x00\x0cMacintosh HD\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xce\x97\xab\xc3H+\x00\x00\x01\x88[\x88\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02u\xab\x8d\xd1\x94\\\xb0devrddsk\xff\xff\xff\xff\x00\x00\t \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04pivx\x00\x10\x00\x08\x00\x00\xce\x97\xab\xc3\x00\x00\x00\x11\x00\x08\x00\x00\xd1\x94\\\xb0\x00\x00\x00\x01\x00\x14\x01\x88[\x88\x00\x16\xa9\t\x00\x08\xfaR\x00\x08\xfaQ\x00\x02d\x8e\x00\x0e\x00\x02\x00\x00\x00\x0f\x00\x1a\x00\x0c\x00M\x00a\x00c\x00i\x00n\x00t\x00o\x00s\x00h\x00 \x00H\x00D\x00\x13\x00\x01/\x00\x00\x15\x00\x02\x00\x14\xff\xff\x00\x00\xff\xff\x00\x00',
    'backgroundColorBlue': 1.0,
    'iconSize': 96.0,
    'backgroundColorGreen': 1.0,
    'arrangeBy': 'none',
    'showIconPreview': True,
    'gridSpacing': 100.0,
    'gridOffsetY': 0.0,
    'showItemInfo': False,
    'labelOnBottom': True,
    'backgroundType': 2,
    'backgroundColorRed': 1.0
}
alias = Alias().from_bytes(icvp['backgroundImageAlias'])
alias.volume.name = appname
alias.volume.posix_path = '/Volumes/' + appname
icvp['backgroundImageAlias'] = alias.to_bytes()
ds['.']['icvp'] = icvp

ds['.']['vSrn'] = ('long', 1)

ds['Applications']['Iloc'] = (370, 156)
ds['PIVX-Qt.app']['Iloc'] = (128, 156)

ds.flush()
ds.close()

# ------------------------------------------------

if config.dmg is not None:

    print("+ Preparing .dmg disk image +")

    if verbose:
        print("Determining size of \"dist\"...")
    size = 0
    for path, dirs, files in os.walk("dist"):
        for file in files:
            size += os.path.getsize(os.path.join(path, file))
    size += int(size * 0.15)

    if verbose:
        print("Creating temp image for modification...")

    tempname: str = appname + ".temp.dmg"

    run(["hdiutil", "create", tempname, "-srcfolder", "dist", "-format", "UDRW", "-size", str(size), "-volname", appname], check=True, universal_newlines=True)

    if verbose:
        print("Attaching temp image...")
    output = run(["hdiutil", "attach", tempname, "-readwrite"], check=True, universal_newlines=True, stdout=PIPE).stdout

    m = re.search(r"/Volumes/(.+$)", output)
    disk_root = m.group(0)

    print("+ Applying fancy settings +")

    bg_path = os.path.join(disk_root, ".background", os.path.basename('background.tiff'))
    os.mkdir(os.path.dirname(bg_path))
    if verbose:
        print('background.tiff', "->", bg_path)
    shutil.copy2('background.tiff', bg_path)

    os.symlink("/Applications", os.path.join(disk_root, "Applications"))

    print("+ Finalizing .dmg disk image +")

    run(["hdiutil", "detach", f"/Volumes/{appname}"], universal_newlines=True)

    run(["hdiutil", "convert", tempname, "-format", "UDZO", "-o", appname, "-imagekey", "zlib-level=9"], check=True, universal_newlines=True)

    os.unlink(tempname)

# ------------------------------------------------

print("+ Done +")
>>>>>>> 6ed103f204953728b4b97b6363e44051b274582e

sys.exit(0)
